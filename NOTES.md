# Factors of an Algorithm

1. **Modularity** - This feature was perfectly designed for the algorithm if you are given a problem and break it down into small-small modules or small-small steps, which is a basic definition of an algorithm.

2. **Correctness** - An algorithm's correctness is defined as when the given inputs produce the desired output, indicating that the algorithm was designed correctly. An algorithm's analysis has been completed correctly.

3. **Maintainability** - It means that the algorithm should be designed in a straightforward structured way so that when you redefine the algorithm, no significant changes are made to the algorithm.

4. **Functionality** - It takes into account various logical steps to solve a real-world problem.

5. **Robustness** - Robustness refers to an algorithm's ability to define your problem clearly.

6. **User-Friendly** - If the algorithm is difficult to understand, the designer will not explain it to the programmer.

7. **Simplicity** - If an algorithm is simple, it is simple to understand.

8. **Extensibility** - Your algorithm should be extensible if another algorithm designer or programmer wants to use it.

---

# Characteristics of an Algorithm

## Well-Defined Inputs

1. The expected inputs of an algorithm must be well-defined to ensure its correctness, predictability, and repeatability.

2. Well-defined inputs ensure that the algorithm's behavior is deterministic, meaning the same input will always produce the same output.

3. Unambiguous inputs help prevent incorrect implementations and misunderstanding of the algorithm's requirements.

4. With well-defined inputs, it is easier to optimize the algorithm based on the characteristics of the input.

## Well-Defined Outputs

1. The outputs of an algorithm should be well-defined to ensure that the algorithm produces the intended and accurate result for a given set of inputs.

2. It avoids ambiguity and guarantees that the algorithm solves the problem correctly.

3. It is also easy to verify the correctness of the algorithm's implementation.

4. Well-defined outputs allow you to optimize the algorithm further to achieve the results more efficiently.

## Unambiguity

1. Ambiguity is the algorithm's description can lead to incorrect implementations and unreliable results. That is why it is important for an algorithm to be unambiguous.

2. It allows the algorithm to be predictable, i.e., the same input produces the same output, making debugging an implementation easier.

3. It is also easier for unambiguous algorithms to be standardized and used widely for different applications.

4. While implementing unambiguous algorithms, you can focus more on optimizations rather than handling unexpected errors and edge cases.

## Finiteness

1. The algorithm should end after a finite amount of time, and it should have a limited number of instructions.

2. A finite algorithm ensures that it will eventually stop executing and produce a result.

3. An infinite algorithm would never reach a conclusion, which is impractical in real-world scenarios where computation cannot be performed indefinitely.

4. The time and space complexity can be analyzed in the case of a finite algorithm, which is important for performing further optimizations.

## Language Independence

1. A language-independent algorithm can be easily ported to different programming languages and platforms, making it more adaptable and usable across various environments.

2. Being language-independent also makes an algorithm future-proof, which means it can be implemented easily using newer programming languages.

3. It is important for algorithms to be language-independent in educational settings where students are exposed to different programming languages.

4. It also makes it easier to compare the algorithm's performance using different programming languages.

## Effectiveness and Feasibility

1. An algorithm should be feasible because feasibility indicates that it is practical and capable of being executed within reasonable constraints and resources.

2. It also avoids excessive execution times, which can make an algorithm unusable in real-world scenarios.

3. Feasible algorithms can be easily implemented using existing hardware infrastructure without using specialized resources.

4. They are adopted easily for usage across fields due to their practical hardware requirements.

# Data Flow Diagramming

## What is a data flow diagram?

A data flow diagram shows the way information flows through a process or system. It includes data inputs and outputs, data stores, and the various subprocesses the data moves through. DFDs are built using standardized symbols and notation to describe various entities and their relationships.

![img of a data flow diagram](https://d2slcw3kip6qmk.cloudfront.net/marketing/pages/chart/seo/data-flow-diagram/discovery/data-flow-diagram-7.svg)

## Physical and Logical Data Flow Diagrams

Logical data flow diagrams focus on **what** happens in a particular inforamtion flow.

Physical data flow diagrams focus on **how** things happen in an information flow.

## Data Flow Diagram Levels

1. Level 0 DFDs - Also known as context diagrams, are the most basic data flow diagrams. They provide a broad view that is easily digestable but offers little detail.

2. Level 1 DFDs - Are still a general overview but they go into more detail than a context diagram.

3. Level 2+ DFDs - simple break processes down into more detailed sub-processes.

# Classes

![img breaking down classes](https://miro.medium.com/v2/resize:fit:828/format:webp/1*NxXw72-CDGp7b7pz2kga5g.png)